#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

#define VERTEX_MAX 5000
#define EDGE_MAX ((vertex_num * (vertex_num + 1)) / 2)


typedef struct Edge{
    int start;
    int end;
    int weight;
}Edge;


int error_check(int vertex_num, int edge_num)
{
    if (vertex_num < 0 || vertex_num > VERTEX_MAX)
    {
        puts("bad number of vertices");
        return -1;
    }
    if (edge_num < 0 || edge_num > EDGE_MAX)
    {
        puts("bad number of edges");
        return -1;
    }
    return 0;
}


long long min_key(int edge_num, int included[], long long min_edge[])
{
    long long min = LONG_LONG_MAX;
    int min_index;
    for (int i = 0; i < edge_num; i++)
    {
        if (included[i] == 0 && min_edge[i] < min)
        {
            min = min_edge[i];
            min_index = i;
        }
    }
    return min_index;
}


void prim(long long** graph, int edge_num, int vertex_num)
{
    int included[edge_num];
    long long min_edge[edge_num], min_idx, parent[edge_num], len;

    for (int i = 0; i < edge_num; i++)
    {
        min_edge[i] = LONG_LONG_MAX;
        included[i] = 0;
    }

    min_edge[0] = 0;
    parent[0] = -1;

    for (int i = 0; i < edge_num; i++)
    {
        min_idx = min_key(edge_num, included, min_edge);
        included[min_idx] = 1;
        for (int j = 1; j < edge_num + 1; j++)
        {
            if (graph[min_idx][j] && included[j] == 0 && graph[min_idx][j] < min_edge[j])
            {
                parent[j] = min_idx;
                min_edge[j] = graph[min_idx][j];
            }
        }
    }

    len = 0;
    for (int i = 1; i < edge_num; i++)
        len += graph[i][parent[i]];

    if (len == 0)
        puts("no spanning tree");
    else
    {
        for (int i = 1; i < vertex_num; i++)
            if (parent[i] + 1 < i + 1)
                printf("%lld %d\n", parent[i] + 1, i + 1);
            else
                printf("%d %lld\n", i + 1, parent[i] + 1);
    }
}


int main()
{
    FILE* file = fopen("in.txt", "r");
    int vertex_num, edge_num, edge_start, edge_end;
    long long edge_weight;
    fscanf(file, "%d", &vertex_num);
    fscanf(file, "%d", &edge_num);

    if (error_check(vertex_num, edge_num) == -1)
        return 0;
    if (vertex_num == 1)
        return 0;


    long long** graph = (long long**)malloc(vertex_num * sizeof(long long *));
    int cnt = 0;

    for (int i = 0; i < vertex_num; i++)
        graph[i] = (long long *)calloc(vertex_num, sizeof(long long));

    for (int i = 0; i < edge_num; i++)
    {
        if (fscanf(file, "%d %d %lld", &edge_start, &edge_end, &edge_weight) != 3)
        {
            fclose(file);
            puts("bad number of lines");
            return 0;
        };

        if (edge_weight < 0 || edge_weight > INT_MAX)
        {
            puts("bad length");
            return 0;
        }

        if (edge_start < 1 || edge_start > vertex_num ||
        edge_end < 1 || edge_end > vertex_num)
        {
            puts("bad vertex");
            return 0;
        }

        if (edge_end == vertex_num)
            cnt++;

        graph[edge_start - 1][edge_end - 1] = edge_weight;
        graph[edge_end - 1][edge_start - 1] = edge_weight;
    }
    if (cnt == 0)
    {
        puts("no spanning tree");
        return 0;
    }

    prim(graph, edge_num, vertex_num);

    for (int i = 0; i < edge_num; i++)
        free(graph[i]);
    free(graph);

    fclose(file);
    return 0;
}
